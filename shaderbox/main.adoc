= Rapid Prototyping of Graphics Shaders in Modern C++
:revealjs_theme: black
:revealjs_transition: fade
:revealjs_controls: true
:revealjs_progress: true
:revealjs_slideNumber: true
:revealjs_history: true
:revealjs_overview: true
:revealjs_fragments: true
:customcss: main.css
:title-slide-background-image: img/title.png
:source-highlighter: highlightjs
:icons: font

[background-image="img/sd-brand/banner.jpg"]
== Valentin Galea
https://twitter.com/valentin_galea[@valentin_galea]

More than 10 years in
_mobile_, _indie_ and _AAA_ games

image::img/sd-brand/SD-logo-white.svg[SD, 128, 128]

== Agenda
- Intro and Motivation
- Shading Languages
- C++
- Showcase

TIP: questions welcomed throughout

== Shaders
[quote]
A computer program that is used to do *shading*
// originally from https://www.clicktorelease.com/talks/scotlandjs-2015/

[%notitle, background-image="img/intro/shaded_shapes.jpg"]
== Shaders Definition
// from https://www.clicktorelease.com/talks/scotlandjs-2015/files/CubeSphereConeCylinderNoBackgrnd.jpg
// alternative: https://qph.ec.quoracdn.net/main-qimg-f441c2d9b120a389f6fa5c995080adaf-c

[quote, Wikipedia]
Depicting depth perception in 3D models or illustrations by varying levels of darkness

[%notitle, background-image="img/intro/pixar_luxo.jpg"]
== Shaders Pixar
// from https://i.ytimg.com/vi/lkKf9DWmR04/maxresdefault.jpg

[quote, Pixar RenderMan 1988]
A computer program that tells the computer how to draw something
//image::https://upload.wikimedia.org/wikipedia/commons/8/84/Phong-shading-sample.jpg[]
// public domain

[state=GPU]
== Shaders on Modern GPU's
image::img/intro/gpu_gtx1080.png[GPU, width="60%", float="right"]

[%left]
`-` Computer graphics

[%left]
`-` Image manipulation

[%left]
`-` Highly parallel computing

== Why on GPU
image::img/intro/cpu_vs_gpu.png[]
// https://steemit.com/gridcoin/@dutch/hardware-and-project-selection-part-1-cpu-vs-gpu

== Types of Shaders
image::img/intro/pipeline.png[pipeline, float="right"]
// https://open.gl/drawing https://creativecommons.org/licenses/by-sa/4.0/

[%left]
Vertex +
Geometry +
Tessellation +
Fragment(Pixel) +
`-----` +
Compute

== Pixel/Fragment Shader
image::img/intro/materials.jpg[mat, width="80%"]

IMPORTANT: We will concentrate on (procedurally generated) image-only shaders

== Motivation
I wanted to create real-time effects like...

[%notitle, background-image="img/motivation/snail.jpg"]
== Example 1

[%notitle, background-image="img/motivation/rainforest.png"]
== Example 2

[%notitle, background-image="img/motivation/temple.png"]
== Example 3

[state=GPU]
== !
on more limited devices...

[cols="a,a"]
|=================
|
image:img/motivation/galaxy-s7-edge.png[s7]
|
image:img/motivation/tablet-pc.png[tablet-pc]
|=================

[state=commute]
== !
image::img/motivation/commute.png[background]
...because of long commutes!

[state=gpu_bug]
== !
image::img/motivation/snail-bug.png[background]

also because GPU driver render bugs

WARNING: taken on desktop PC / Nvidia GTX 1060

== Other advantages

[cols="a,a"]
|=================
|
- Debug / Decompile algorithms from
* http://www.shadertoy.com[shadertoy.com]
* http://www.glslsandbox.com[glslsandbox.com]
- Unit Test shaders!
- Quick prototype
|
image:img/motivation/shadertoy.png[shadertoy]
|=================

== Shading Languages
[state=RSL]
== Pixar RenderMan Language
image::img/intro/renderman.jpg[background]

[source, javascript, role="strech"]
-----
/*
 * red mesh                   red shaded mesh
 */
surface basic() {             surface simple(color myOpacity = 1) {
    Ci = (1.0, 0.0, 0.0);         color myColor = (1.0, 0.0, 0.0);
    Oi = 1;                       normal Nn = normalize(N);
}                                 Ci = myColor * myOpacity * diff;
                                  Oi = myOpacity;
                              }
-----

== Shading Languages History
For real-time rendering:

- Early: ARB assembly, Cg
- OpenGL shading language (*GLSL*)
- DirectX High-Level Shader Language (*HLSL*)
- PlayStation Shader Language (similar to HLSL)

== GLSL and HLSL
// from https://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/lighting.php
[source, javascript]
-----
varying vec3 N;
varying vec3 v;
void main(void)
{
   vec3 L = normalize(gl_LightSource[0].position.xyz - v);
   vec4 Idiff = gl_FrontLightProduct[0].diffuse * max(dot(N,L), 0);
   Idiff = clamp(Idiff, 0.0, 1.0);
   gl_FragColor = Idiff;
}
-----

// from https://www.gamasutra.com/view/feature/131275/implementing_lighting_models_with_.php?page=2
[source, javascript]
-----
float4 main(
    float3 Light: TEXCOORD0,
    float3 Norm : TEXCOORD1) : COLOR
{
    float4 diffuse = { 1.0, 0.0, 0.0, 1.0 };
    float4 ambient = { 0.1, 0.0, 0.0, 1.0 };
    return ambient + diffuse * saturate(dot(Light, Norm));
}
-----

== GLSL vs HLSL: general
// from https://docs.microsoft.com/en-us/windows/uwp/gaming/glsl-to-hlsl-reference
|==============================================================================
| Procedural, step-centric (C like) | Object oriented, data-centric (C++ like)
| Compilation done in driver        | Client side compilation
| `float`, `int`, `bool`            | `float`, `int`, `bool`, `uint`, `double`
|==============================================================================

== GLSL vs HLSL: types
|==============================================================================
| Vector type: `vec2`, `vec3`, `vec4` | Vector type: `float2`, `float3`, `float4`
| Matrix type: `mat2`, `mat3`, `mat4` | Matrix type: `float2x2`, `float3x3`, `float4x4`
2+^| ...textures, samplers, precision modifiers etc
|==============================================================================

== Shading Languages Future
Basically C++ (usually via LLVM)

[.step]
- Metal Shading Language (C++14, Apple)
 * only on iOS devices
- CUDA Heterogeneous Computing (C++11, NVidia)
 * only for computing, not graphics
- HLSL 6.x (C++98'ish, Microsoft)
 * not released yet

== !
Let's see how C++ can help out, NOW!

[state=plan]
== The Plan
[%step]
- image:img/icon/browser.svg[cpp, 64, 64] Pick a shading language and twist C++ to accept it as source code!
- image:img/icon/management.svg[bonus, 64, 64] BONUS: use the preprocessor for transcription back to the original language(s)!

== The Plan (cont.)
[%step]
- obligatory preprocessor layer
- vector (linear algebra) types
 * swizzle support
- matrix types
- operators
- "standard library" utility/math functions

== Place Your Bets
We will chose *GLSL* as it's used on _desktop_, _web_ and _mobile_

WARNING: only a subset of it - concentrate on procedural graphics thus minimize/eliminate inputs (textures, vertex data, etc)

== Languages: Declarations
|==============================================================================
| GLSL              | HLSL                  | C++
3+^|
// stupid asciidoctor bug: doesn't respect column centering
{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}
C-style types and arrays
3+^|
{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}
C-style `struct`
| `T name = T ( ... )` | `T name = { ... }` |  both (preproc abstraction)
|==============================================================================

== Languages: Arguments
|===========================================
| GLSL/HLSL     | C++           | Macro glue
| `const in T`  | `const T &`   | `_in(T)`
| `inout T`     | `T &`         | `_inout(T)`
| `out T`       | `T &`         | `_out(T)`
|===========================================

== Vectors and Matrices
[source, cpp]
-----
// vectors are generic
vec2 texcoord1, texcoord2;
vec3 position;
vec4 myRGBA;
ivec2 textureLookup;
bvec3 less;

// matrices are floating point only
mat2 mat2D;
mat3 optMatrix;
mat4 view, projection;
-----

== Vector Swizzle
Syntactic sugar for easy referring to components (or combination of)

|=========================
| { x, y, z, w } | to represent points or normals
| { r, g, b, a } | to refer to colors (`a` is alpha/translucency)
| { s, t, p, q } | texture coordinates
|=========================

== Vector Swizzle - Examples
.subcomponents mix & match
[source, cpp]
-----
vec4 v4;
v4.rgba;  // is a vec4 and the same as just using v4,
v4.rgb;   // is a vec3,
v4.b;     // is a float,
v4.xy;    // is a vec2,
-----

[source, cpp]
-----
vec4 pos = vec4(1.0, 2.0, 3.0, 4.0);
vec4 swiz= pos.wzyx; // swiz = (4.0, 3.0, 2.0, 1.0)
vec4 dup = vec4(pos.xx, pos.yy);
-----

.l-value assigment
[source, cpp]
-----
pos.xw = vec2(5.0, 6.0); // pos = (5.0, 2.0, 3.0, 6.0)
pos.xx = vec2(3.0, 4.0); // illegal - 'x' used twice
-----

== Vector Swizzle - Motivation
[source, cpp]
-----
vec3 calcNormal( in vec3 pos )
{
    vec2 e = vec2(1.0, -1.0) * 0.0005;

    return normalize(
        e.xyy * map( pos + e.xyy ).x + 
        e.yyx * map( pos + e.yyx ).x + 
        e.yxy * map( pos + e.yxy ).x + 
        e.xxx * map( pos + e.xxx ).x );
}
-----

== Operators
[cols="a,a"]
|============
| syntax | equivalent
|
[source, cpp]
-----
w = v + u;
-----
|
[source, cpp]
-----
w.x = v.x + u.x;
w.y = v.y + u.y;
w.z = v.z + u.z;
-----
|
[source, cpp]
-----
u = v * m;
-----
|
[source, cpp]
-----
u.x = dot(v, m[0]);
u.y = dot(v, m[1]);
u.z = dot(v, m[2]);
/* dot(a,b) is the inner product of a and b */
-----
|============

[state=STL]
== "Standard Library"
//TODO: table styling attrib are ignored
[cols="%20,%80", width="100%"]
|==========================================================
| Math      | `sin`, `cos`, `radians`, `pow`, `exp`, etc
| Common    | `abs`, `sign`, `floor`, `mod`, `min`, etc
| Utility   | `mix`, `step`, `smoothstep`, etc
| Geometry  | `length`, `dot`, `cross`, `distance`, etc 
2+| Specific texture and image sampling ...
|==========================================================

== !
Recreating all this in C++ ...

[state=no_list_decor]
== Design of `vector<>`
[%step]
- {blank}
+
[source, cpp]
-----
template<typename T, size_t N>
struct vector :
    public vector_base<T, N>
{
-----
- {blank}
+
[source, cpp]
-----
    vector();
    explicit vector(scalar_type s);
    template<typename... Args> explicit vector(Args... args);

-----
- {blank}
+
[source, cpp]
-----
    scalar_type& operator[](size_t i);
    scalar_type& operator[](size_t i);

    vector_type& operator +=(scalar_type s);
    vector_type& operator +=(const vector_type& v);
(etc)
-----

== `vector<>` ctor - basic
[source, cpp]
-----
vector()
{
    static_for<0, N>()([this](size_t i) {
        data[i] = 0;
    });
}

explicit vector(scalar_type s)
{
    static_for<0, N>()([s, this](size_t i) {
        data[i] = s;
    });
}
-----

[state=no_list_decor]
== `static_for` utility
[%step]
- {blank}
+
[source, cpp]
-----
template<size_t Begin, size_t End>
struct static_for
{
    template<class Func>
    constexpr void operator ()(Func&& f)
    {
        f(Begin);
        static_for<Begin + 1, End>()(std::forward<Func>(f));
    }
};
-----
- {blank}
+
[source, cpp]
-----
template<size_t N>
struct static_for<N, N>
{
    template<class Func>
    constexpr void operator ()(Func&&) { /* empty */ }
};
-----

== `vector<>` ctor - advanced
[source, cpp]
template<typename A0, typename... Args,

[source, cpp]
    class = typename std::enable_if<
        ((sizeof... (Args) >= 1) ||
        ((sizeof... (Args) == 0) && !std::is_scalar_v<A0>))
    >::type>

[source, cpp]
explicit vector(A0&& a0, Args&&... args)
{
    iterate_construct<0, num_components>(
        std::forward<A0>(a0), std::forward<Args>(args)...
    );
}

//TODO: step

== `vector<>` ctor - advanced (2)
[source, cpp]
template<size_t I, size_t IMax, typename Arg0, typename... Args>
void iterate_construct(Arg0&& a0, Args&&... args)
{
    if constexpr (I < IMax) {
        construct_at_index(I, std::forward<Arg0>(a0));
        iterate_construct<I + get_size<Arg0>(), IMax>(
            std::forward<Args>(args)...);
    }
}

[source, cpp]
template<size_t I, size_t IMax>
void iterate_construct()
{
}

== `vector<>` ctor - advanced (3)
[source, cpp]
-----
void construct_at_index(size_t& i, scalar_type arg)
{
    data[i++] = arg;
}
-----

[source, cpp]
-----
template<typename Other, size_t Other_N>
void construct_at_index(size_t& i, vector<Other, Other_N>&& arg)
{
    constexpr auto count = std::min(N, Other_N);

    detail::static_for<0, count>()([&](size_t j) {
        data[i++] = arg.data[j];
    });
}
-----

== `vector<>` ctor in action
[source, cpp]
-----
using vec2 = vector<int, 2>;
using vec3 = vector<int, 3>;

vec3 v = vec3(98, vec2(99, 100));
//             ^    ^
//             |    |
//             `-- scalar construct gets called
//                  |
//                  `---- sub-vector construct gets called
//                        and then recursively again
-----

== Godbolt
[source, cpp]
-----
int main()
{
    float a, b;
    scanf("%f %f", &a, &b);

    auto v = vec3(1.f, vec2(a, b));

    printf("%f %f", v.x, v.y);
}
-----

`-std=c++17 -Wall -O2` https://tinyurl.com/godbolt[(source)]

// VML: https://godbolt.org/z/sVJV5W
// VML -Ofast https://godbolt.org/z/2mD0zn

[state=godbolt]
== Godbolt (cont.)

[cols="a,a,a"]
|==================
| clang (5.x/6.x) | gcc (7.x/8.x) | msvc (2017)

| [source, cpp]
-----
call    scanf
movss   xmm0, dword ptr [rsp + 4]
cvtss2sd        xmm1, xmm0
movss   xmm0, dword ptr [rsp]
cvtss2sd        xmm2, xmm0
movsd   xmm0, qword ptr [rip + .LCPI0_0]
mov     edi, offset .L.str.1
mov     al, 3
call    printf
-----

| [source, cpp]
-----
call    scanf
pxor    xmm2, xmm2
pxor    xmm1, xmm1
movsd   xmm0, QWORD PTR .LC1[rip]
mov     edi, OFFSET FLAT:.LC2
mov     eax, 3
cvtss2sd        xmm2, DWORD PTR [rsp+12]
cvtss2sd        xmm1, DWORD PTR [rsp+8]
call    printf
-----

| [source, cpp]
-----
call    scanf
movss   xmm1, DWORD PTR b$[rsp]
lea     rcx, OFFSET FLAT:`string'
movss   xmm0, DWORD PTR a$[rsp]
movss   DWORD PTR $T1[rsp+4], xmm1
movsd   xmm1, QWORD PTR __real@3ff0000000
movss   DWORD PTR $T1[rsp], xmm0
movq    rdx, xmm1
mov     rax, QWORD PTR $T1[rsp]
mov     QWORD PTR <args_1>$[rsp], rax
movss   xmm3, DWORD PTR <args_1>$[rsp+4]
movss   xmm2, DWORD PTR <args_1>$[rsp]
cvtps2pd xmm3, xmm3
cvtps2pd xmm2, xmm2
movq    r9, xmm3
movq    r8, xmm2
call    printf
-----
|==================

//- TRIVIA: gcc's `cvtss2sd` from memory is pessimization (https://stackoverflow.com/a/16597686)

== Problem: Debug

[source, cpp]
void detail::static_for<0ul, 3ul>::operator()<vector<float, 3ul>...
    push    rbp
    mov     rbp, rsp
    sub     rsp, 32
    mov     QWORD PTR [rbp-24], rdi
    mov     QWORD PTR [rbp-32], rsi
    mov     rax, QWORD PTR [rbp-32]
    mov     esi, 0
    mov     rdi, rax
    call    vector<float, 3ul>::vector(float)::{lambda(unsigned...
    mov     rax, QWORD PTR [rbp-32]
    mov     rdi, rax
    call    vector<float, 3ul>::vector(float)::{lambda(unsigned...
    mov     rdx, rax
    lea     rax, [rbp-1]
    mov     rsi, rdx
    mov     rdi, rax
    call    void detail::static_for<1ul, 3ul>::operator()<vector...
    nop
    leave
    ret

[state=no_list_decor]
== Improved design of `vector<>`
[%step]
- {blank}
+
[source, cpp]
-----
template<typename T, size_t... Ns>
struct vector :
    public vector_base<T, Ns...>
{

-----
- {blank}
+
[source, cpp]
-----
    vector()
    {
        ((data[Ns] = 0), ...);
    }
-----
- {blank}
+
[source, cpp]
-----
    explicit vector(scalar_type s)
    {
        ((data[Ns] = s), ...);
    }

    template<typename A0, typename... Args> explicit vector
(etc)
-----

== Folding Expressions
NOTE: `C++17` unary fold expression over comma operator

.Compatibility
- gcc 6+
- clang 3.6+
- MSVC 2017 15.5+

//TODO: Fold Expressions N4295 gcc(6) clang(3.6) msvc(VS 2017 15.5)

== Improved `vector<>` ctor
[source, cpp]
-----
template<typename A0, typename... Args>
explicit vector(A0&& a0, Args&&... args)
{
    size_t i = 0; // advances as we consume args

    // consume the first one
    construct_at_index(i, std::forward<A0>(a0));

    // consume the rest, if any
    (construct_at_index(i, std::forward<Args>(args)), ...);
}
-----

== `vector_base` naive impl
[source, cpp]
-----
template<typename T>
struct vector_base<T, 2>
{
    union
    {
        T data[2];
        struct { T x, y; };
        struct { T s, t; };
        struct { T u, v; };
    }
};
-----

== `vector_base` naive impl (2)
[source, cpp]
-----
template<typename T>
struct vector_base<T, 3>
{
    union
    {
        T data[3];
        struct { T x, y, z; };
        struct { T r, g, b; };
        struct { T s, t, p; };
    }
};
-----

== `vector_base` naive impl (3)
[source, cpp]
-----
template<typename T>
struct vector_base<T, 4>
{
    union
    {
        T data[4];
        struct { T x, y, z, w; };
        struct { T r, g, b, a; };
        struct { T s, t, p, q; };
    }
};
-----

== `vector_base` notes
NOTE: both anonymous `struct` and `union` are permitted, only MSVC complains with warning

WARNING: `union` active member switching can be tricky `[10.5]` but we'll use only trivial types with trivial assignment 

== Swizzle
TIP: We introduce an additional proxy class that allows custom access to the indices and we create all possible permutations (per GLSL/HLSL standard)

[source, cpp]
-----
template<class vector_type, class T, size_t N, size_t... indices>
struct swizzler
{
    T data[N]; // can differ from vector_type
...
};
-----

== Swizzle for `vector<T, 3>`
[source, cpp]
-----
union
{
    T data[3];

    struct {
        swizzler<0>::type x;
        swizzler<1>::type y;
        swizzler<2>::type z;
    };
    struct {
        swizzler<0>::type r;
        swizzler<1>::type g;
        swizzler<2>::type b;
    };
    struct {
        swizzler<0>::type s;
        swizzler<1>::type t;
        swizzler<2>::type p;
    };
    ...
-----

== swizzle (cont.)
[source, cpp]
-----
    ...
    swizzler<0, 0>::type xx, rr, ss;
    swizzler<0, 1>::type xy, rg, st;
    swizzler<0, 2>::type xz, rb, sp;
    swizzler<1, 0>::type yx, gr, ts;
    swizzler<1, 1>::type yy, gg, tt;
    swizzler<1, 2>::type yz, gb, tp;
    swizzler<2, 0>::type zx, br, ps;
    swizzler<2, 1>::type zy, bg, pt;
    swizzler<2, 2>::type zz, bb, pp;
    ...
-----

== ...more swizzle
[source, cpp]
-----
    ...
    swizzler<0, 0, 0>::type xxx, rrr, sss;
    swizzler<0, 0, 1>::type xxy, rrg, sst;
    swizzler<0, 0, 2>::type xxz, rrb, ssp;
    swizzler<0, 1, 0>::type xyx, rgr, sts;
    swizzler<0, 1, 1>::type xyy, rgg, stt;
    swizzler<0, 1, 2>::type xyz, rgb, stp;
    swizzler<0, 2, 0>::type xzx, rbr, sps;
    swizzler<0, 2, 1>::type xzy, rbg, spt;
    swizzler<0, 2, 2>::type xzz, rbb, spp;
    swizzler<1, 0, 0>::type yxx, grr, tss;
    swizzler<1, 0, 1>::type yxy, grg, tst;
    swizzler<1, 0, 2>::type yxz, grb, tsp;
    ...
-----

== ...even more swizzle!
[source, cpp]
-----
    ...
    swizzler<2, 1, 2, 0>::type zyzx, bgbr, ptps;
    swizzler<2, 1, 2, 1>::type zyzy, bgbg, ptpt;
    swizzler<2, 1, 2, 2>::type zyzz, bgbb, ptpp;
    swizzler<2, 2, 0, 0>::type zzxx, bbrr, ppss;
    swizzler<2, 2, 0, 1>::type zzxy, bbrg, ppst;
    swizzler<2, 2, 0, 2>::type zzxz, bbrb, ppsp;
    swizzler<2, 2, 1, 0>::type zzyx, bbgr, ppts;
    swizzler<2, 2, 1, 1>::type zzyy, bbgg, pptt;
    swizzler<2, 2, 1, 2>::type zzyz, bbgb, pptp;
    swizzler<2, 2, 2, 0>::type zzzx, bbbr, ppps;
    swizzler<2, 2, 2, 1>::type zzzy, bbbg, pppt;
    swizzler<2, 2, 2, 2>::type zzzz, bbbb, pppp;
};
-----

== `swizzler<>` design
[source, cpp]
-----
template<
    typename vector_type,
    typename scalar_type,
    size_t N,
    size_t... indices>
struct swizzler
{
    T data[N];
    // N might differ from vector_type::num_components
    // ex: .xxxx from vec2

(etc)
-----

== `swizzler<>` generator
[source, cpp]
template<typename T, size_t... Ns>
struct vector_base
{
    template<size_t... indices>
    struct swizzler_wrapper_factory
    {
        using type = swizzler<
            typename vec_equiv<T, sizeof...(indices)>::type,
            T,
            sizeof...(Ns),
            indices...>;
    };

[source, cpp]
    template<size_t x>
    struct swizzler_wrapper_factory<x>
    {
        using type = T; // one component vectors are just scalars
    };

[state=no_list_decor]
== `swizzler<>` conversions
[%step]
- Needs to implicitly convert/assign to its `vector<>` equivalent
- {blank}
+
[source, cpp]
operator vector_type()
{
    vector_type vec;
    assign_across(vec, 0, indices...);
    return vec;
}
- {blank}
+
[source, cpp]
swizzler& operator=(const vector_type& vec)
{
    assign_across(vec, 0, indices...);
    return *this;
}

== `swizzler<>` design (cont.)
We use same fold expression trick

[source, cpp]
template<typename... Indices>
void assign_across(vector_type& vec, size_t i, Indices ...j) const
{
    ((vec[i++] = data[j]), ...);
}

[source, cpp]
template<typename... Indices>
void assign_across(const vector_type& vec, size_t i, Indices ...j)
{
    ((data[j] = vec[i++]), ...);
}

== `swizzler<>` problem
[source, cpp]
vec3 v = vec4(other.xy, other.zw);

[source, asm]
> error: no matching function for call to [...]
> template argument deduction/substitution failed: [...]

[%step]
- Solution? Introduce another abstraction layer!
- {blank}
+
[source]
(construct_at_index(i, decay(std::forward<Args>(args))), ...);
- `decay` calls equivalent member function (or does nothing for scalar)
- both `vector` and `swizzler` have one so they can interchange easily

[state=no_list_decor]
== Operators and Functions
We will need to re-create a lot of generic utility functions

[%step]
- {blank}
Example: the dot (inner) product of two vectors
- {blank}
+
[source, cpp]
template<typename T, size_t... Ns>
T dot(const vector<T, Ns...> &, const vector<T, Ns...> &);
+
[source, cpp]
float n = dot(vec3(1, 0, 0), vec3(0, 0, 1));

[%notitle, state=no_list_decor]
== Functions problem
WARNING: We immediately hit a big problem!

[source, cpp]
vec3 v = vec3(1, 0, 0);
float n = dot(v.xzx, v.zyx);

[source, asm]
> 'dot': no matching overloaded function found
> could not deduce template argument


== !
NOTE: Type deduction does not consider implicit conversions!

[%step]
.Possible fixes
- {blank}
+
[source, cpp]
float n = dot<float, 0, 1, 2>(v.xzx, v.zyx);
- create by hand all scalar/size combinations :(
- duplicate functions for swizzler proxy as well :|
- SFINAE tricks

[state=no_list_decor]
== A better fix
NOTE: we place the functions in a non-deduced context: inside `vector<>` itself!

[%step]
- {blank}
+
[source, cpp]
template<typename T, size_t... Ns>
struct vector
{
    ...
    friend T dot(const vector& a, const vector& b)
    {
        /* inline friend found via ADL */
    }
    ...

== Enough?
WARNING: No!

[%step]
- {blank}
+
.lots of function need to work with scalars only
[source, cpp]
float opS(float d1, float d2)
{
    return max(-d2, d1);
}
- {blank}
+
.ambiguity with literals
[source, cpp]
-----
smoothstep(0, 1, v.xyz);

// could be `int`, `float` or `double`
-----

[state=no_list_decor]
== Solution
Inspect the list of function args and deduct a vector type using `std::common_type` techniques

[%step]
- {blank}
+
.first: need to make `vec1` convert to/from scalars
[source, cpp]
std::is_convertible<vec1, float>::value == true
- {blank}
+
.then: write the custom traits
[source, cpp]
promote_to_vec< float                >::type == vec1
- {blank}
+
[source, cpp]
promote_to_vec< vec3                 >::type == vec3
promote_to_vec< decltype(vec3().xyz) >::type == vec3
- {blank}
+
[source, cpp]
promote_to_vec< vec3, float          >::type == vec3
promote_to_vec< vec3, float, double  >::type == vec3

== Solution (cont.)
.Insted of `inline` functions are `static`
[source, cpp]
template<template<class, size_t...> class vector, class T, size_t...
struct builtin_func_lib
{
    static T dot(const vector& a, const vector& b)
(etc)

.Create an all-forwarding monster function
[source, cpp]
template<class... Args>
inline auto func(Args&&... args) ->
    decltype(decay(
        promote_to_vec<Args...>::type::
        func(std::forward<Args>(args)...)))
{
    return
        promote_to_vec<Args...>::type:: 
        func(std::forward<Args>(args)...);
}

== the `matrix<>` datatype
Now that we have `vector<>` a matrix is more straightforward

NOTE: two dimensional -> introduce helper type for the indices

[source, cpp]
template<size_t...>
struct indices_pack;

== the `matrix<>` datatype (cont.)
[source, cpp]
template<
    typename scalar_type,
    template<typename, size_t...> class vector_type,
    size_t... Columns,
    size_t... Rows
>
struct matrix<scalar_type, vector_type, 
    indices_pack<Columns...>, indices_pack<Rows...>>

[source, cpp]
-----
{
    static constexpr auto N = sizeof...(Columns);
    static constexpr auto M = sizeof...(Rows);

    using column_type = vector_type<scalar_type, Columns...>;
    using row_type = vector_type<scalar_type, Rows...>;

    column_type data[M];
(etc)
-----

== the `matrix<>` constructors
[source, cpp]
matrix() = default; // zeroes all data

[source, cpp]
explicit matrix(scalar_type s) // fill in diagonally
{
    ((data[Rows][Rows] = s), ...);
}

[source, cpp]
template<typename... Args>
explicit matrix(Args&&... args)
{
    size_t i = 0;
    (construct_at_index(i, 
        detail::decay(std::forward<Args>(args))), ...);
}

== the `matrix<>` ops and funcs
- can recycle the same binary operators as vector if written generic
- except _multiplication_
 * which needs to be handled differently
 * for all variations of `matrix`, `row_type`, `column_type`

== Prior Art
TIP: not invented here :)

[%step]
- clang vector extensions
* {blank}
+
[source, cpp]
typedef float vec3 __attribute__((ext_vector_type(3)));
* very limited in initializations, but support full swizzling
- various libraries
* GLM - `.xyz()` style only
* CXXSwizzle - full spec but slow debug

== Results

== !
...but first: Crash Course into Procedural Graphics!

NOTE: Courtesy of @ReinderNijhoff https://www.shadertoy.com/view/4dSfRc

[%notitle, background-image="img/tutorial/step_1.png"]
== raymarch tutorial step 1
[%notitle, background-image="img/tutorial/step_2.png"]
== raymarch tutorial step 2
[%notitle, background-image="img/tutorial/step_3.png"]
== raymarch tutorial step 3
[%notitle, background-image="img/tutorial/step_4.png"]
== raymarch tutorial step 4
[%notitle, background-image="img/tutorial/step_5.png"]
== raymarch tutorial step 5
[%notitle, background-video="vid/raymarch.mp4", options="loop,muted"]
== raymarch tutorial step 6
[%notitle, background-image="img/tutorial/step_7.png"]
== raymarch tutorial step 7
[%notitle, background-image="img/tutorial/step_8.png"]
== raymarch tutorial step 8

== Showcase

== GPU / desktop PC
- https://www.shadertoy.com/user/valentingalea
- Nvidia GeForce 1060
- 1080p

== CPU / desktop PC
- minimal draw app with https://www.libsdl.org/
- AMD FX 8350 8-core 4.00 GHz
- Microsoft Visual C++ 15.7.6
 * `/O2 /Ob2 /fp:fast /fp:except- /arch:SSE2 /openmp`
- 320 x 240 px

== CPU / mobile phone
- C4Droid app (https://play.google.com/store/apps/details?id=com.n0n3m4.droidc)
- Samsung Galaxy S7
- GCC 7.2.0
 * `-Ofast -march=native -funroll-loops`
- 100 x 100 px

[%notitle, background-video="vid/planet.mp4", options="loop,muted"]
== Planet (GPU)

== Planet (CPU)
|==========================================================================================
| image:img/showcase/pc_planet.png[Planet(PC)] | image:img/showcase/droid_planet.jpg[Planet(Droid), 300, 300]
| Desktop PC                          | Mobile Phone
| .1 FPS :(                           | 5 FPS
|==========================================================================================

[%notitle, background-video="vid/clouds.mp4", options="loop,muted"]
== Clouds (GPU)

== Clouds (CPU)
|==========================================================================================
| image:img/showcase/pc_clouds.png[Clouds(PC)] | image:img/showcase/droid_clouds.jpg[Clouds(Droid), 300, 300]
| Desktop PC                          | Mobile Phone
| 1 FPS                               | 8 FPS
|==========================================================================================

[%notitle, background-video="vid/vinyl.mp4", options="loop,muted"]
== Vinyl Turntable (GPU)

== Vinyl Turntable (CPU)
|==========================================================================================
| image:img/showcase/pc_vinyl.png[Vinyl(PC)] | image:img/showcase/droid_vinyl.jpg[Clouds(Droid), 300, 300]
| Desktop PC                          | Mobile Phone
| 1 FPS                               | 12 FPS
|==========================================================================================

[%notitle, background-video="vid/egg.mp4", options="loop,muted"]
== The End
[%step]
- image:img/icon/twitter.png[Twitter, 64, 64] @valentin_galea
- image:img/icon/github.png[Github, 64, 64] https://github.com/valentingalea/
- image:img/sd-brand/SD-logo-white-orange.svg[SD, 128, 128] https://www.splashdamage.com/

== Attribution
- Piotr Gwiazdowski @gwiazdorrr for original inspiration and help
- Shading and Renderman: Jaume Sanchez | @thespite
- Motivation Shaders: Inigo Quilez https://www.shadertoy.com/view/ld3Gz2 https://www.shadertoy.com/view/ldScDh https://www.shadertoy.com/view/4ttSWf
- GPU pipeline: https://open.gl/ (CC BY-SA 4.0) 
- All other images under "Fair Use"/"Fair Dealing"
